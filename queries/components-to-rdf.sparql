PREFIX rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX fx:   <http://sparql.xyz/facade-x/ns/>
PREFIX xyz:  <http://sparql.xyz/facade-x/data/>
PREFIX xsd:  <http://www.w3.org/2001/XMLSchema#>
PREFIX schema: <https://schema.org/>
PREFIX fabio: <http://purl.org/spar/fabio/>
PREFIX frapo: <http://purl.org/cerif/frapo/>

CONSTRUCT { 
	# #--> Step 6. Construct Knowledge Graph (when the Ontology evolves, change this!!!)
	# Component triples:
	?component a ?componentType ;
		schema:identifier ?id , ?doi ;
		schema:abstract ?label ;
		schema:title ?title ;
		schema:releasedEvent ?bnode0 ;
		schema:image ?image ;
		schema:logo ?logo ;
		schema:isPartOf ?w_package , ?_pilot , ?_project ;
		schema:discussionUrl ?log ;
		schema:license ?licence ;
		schema:copyrightNotice ?copyright ;
		schema:contributor ?contributor ;
		schema:distribution ?resource ;
		schema:workExample ?demo .
	# isPartOf triples:
	?_project a schema:Project .
	# Release Event triples:
	?bnode0 schema:startDate ?date ;
		schema:softwareVersion ?number ;
		schema:releaseNotes ?link .
	# Work Package triples:
	?w_package a fabio:WorkPackage .
	# Pilot triples:
	?_pilot a frapo:Investigation .
	# Project triples:
	?_project a schema:Project .


} 
#SELECT ?id ?type ?description
WHERE {
	 
	SERVICE <x-sparql-anything:> { 
		
		SERVICE <x-sparql-anything:> { 
			
			SERVICE <x-sparql-anything:> { 
				# --> Step 1. Find all .md files in relevant repositories (when the sources evolve, change only this!)
				fx:properties fx:location "./ecosystem/content/_polifonia-project/external-components" ; 
					fx:archive.matches ".+.md" .
				[] fx:anySlot ?file .
			}	
			# --> receives iterator over a query solution ( (?file) ) 
	
			BIND ( ?file as ?componentFile ) .	
			
			# --> Step 2. extract the YAML fontmatter from files with component annotations
			fx:properties fx:location ?componentFile  .
			[] a xyz:YamlFrontMatter ; fx:anySlot ?yaml
		}
	
 		BIND ( ?yaml as ?content ) .
		
		#--> Step 3. parse the YAML content
		fx:properties fx:content ?content ;
			fx:triplifier "com.github.sparqlanything.yaml.YAMLTriplifier" ; fx:blank-nodes "false".
		
		#--> Step 4. Query the Ecosystem Schema annotations (when the schema evolves, change only this!)
		#{  # Components.
			# Id.
			?x xyz:component-id ?id . 
			# Type 
			optional { ?x xyz:type ?type . filter (!isIRI(?type)) } 
			optional { ?x xyz:type [ fx:anySlot ?type ] } 
			# Name
			optional{ ?x xyz:name ?name } 
			# Description
	 		optional { ?x xyz:description ?description } 
			# Image
			optional { ?x xyz:image ?image } 
			# Logo
			optional { ?x xyz:logo ?logo } 
			# Work Package
			optional { ?x xyz:work-package [ fx:anySlot ?wp ] }
			# Pilot
			optional { ?x xyz:pilot [ fx:anySlot ?pilot ] }
			# Project
			optional { ?x xyz:project ?project }
			# Resource
			optional { ?x xyz:resource ?resource }
			# Demo
			optional { ?x xyz:demo ?demo }
			# Release-date
			optional { ?x xyz:release-date ?date . } 
			# Release-number
			optional { ?x xyz:release-number ?number } 
			# Release-link
			optional { ?x xyz:release-link ?link } 
			# Doi
			optional { ?x xyz:doi ?doi } 
			# Changelog
			optional { ?x xyz:changelog ?log } 
			# License
			optional { ?x xyz:licence [ fx:anySlot ?licence ] } 
			# Copyright
			optional { ?x xyz:copyright ?copyright } 
			# Contributors
			optional { ?x xyz:contributors [ fx:anySlot ?contributor ] } 
			# Related-components
			#optional { ?x xyz:related-components ?r_comp} 
			# Informed-by
			#optional { ?x xyz:informed-by ?inf_by} 
			# Use-case
			#optional { ?x xyz:use-case ?use_case} 
	#	} union {  #  Containers
		#	?x xyz:container-id [ fx:anySlot ?id ] . 
	 		#optional { ?x xyz:type ?type . filter (!isIRI(?type)) } .
	 		#optional { ?x xyz:type [ fx:anySlot ?type ] } .
	 		#optional { ?x xyz:description ?description } .
		#}
		#filter (?id != "")
	}
	
	#--> Step 5. Build entities (when entity IRIs design change, modify this!)
	# Entities:
	BIND ( fx:entity ( xyz:, "component/", ?id ) AS ?component ) 
	BIND ( fx:entity ( xyz:, "type/", replace(?type, " ", "") ) AS ?componentType ) 
	BIND ( fx:entity ( xyz:, "work-package/", ?wp ) AS ?w_package ) 
	BIND ( fx:entity ( xyz:, "release-event/", ?id ) AS ?r_event ) 
	BIND ( fx:entity ( xyz:, "pilot/", ?pilot) AS ?_pilot ) 
	BIND ( fx:entity ( xyz:, "project/", ?project) AS ?_project ) 
	# Blank Nodes
	BIND ( fx:bnode ( ?link ) AS ?bnode0 )
	# Literals:
	BIND ( fx:literal ( ?description, "en" ) AS ?label ) 
	BIND ( fx:literal ( ?name, "en" ) AS ?title )
	#BIND ( fx:literal ( ?date, xsd:date ) AS ?r_date)
}
